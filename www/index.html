<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
<title>DO NOT FORGET</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">
<style>
*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

:root {
  --phosphor: #33ff00;
  --phosphor-bright: #7fff33;
  --phosphor-dim: #0a2600;
  --phosphor-mid: #1a5c00;
  --phosphor-glow: rgba(51, 255, 0, 0.5);
  --phosphor-glow-soft: rgba(51, 255, 0, 0.15);
  --screen-bg: #000d00;
  --screen-off: #020202;
  --bezel-body: #2a2a2a;
}

html, body {
  width: 100%; height: 100%;
  overflow: hidden;
  font-family: 'VT323', 'Courier New', monospace;
  -webkit-user-select: none;
  user-select: none;
  -webkit-touch-callout: none;
  -webkit-tap-highlight-color: transparent;
}

body {
  display: flex;
  align-items: center;
  justify-content: center;
  background: radial-gradient(ellipse at 50% 40%, #141414 0%, #090909 60%, #000 100%);
}

/* ─── MONITOR HOUSING ─── */
.monitor {
  position: relative;
  width: 100%;
  height: 100%;
}

/* ─── SCREEN WRAPPER ─── */
.screen-wrapper {
  position: relative;
  width: 100%;
  height: 100%;
  overflow: hidden;
  background: #000;
}

/* ─── SCREEN ─── */
.screen {
  position: relative;
  background: var(--screen-bg);
  padding: 16px 18px;
  padding-top: calc(16px + env(safe-area-inset-top));
  padding-bottom: calc(16px + env(safe-area-inset-bottom));
  padding-left: calc(18px + env(safe-area-inset-left));
  padding-right: calc(18px + env(safe-area-inset-right));
  height: 100%;
  display: flex;
  flex-direction: column;
  overflow: hidden;
}

/* Scanlines */
.screen::after {
  content: '';
  position: absolute;
  inset: 0;
  background: repeating-linear-gradient(
    0deg,
    transparent 0px, transparent 2px,
    rgba(0, 0, 0, 0.1) 2px, rgba(0, 0, 0, 0.1) 4px
  );
  pointer-events: none;
  z-index: 100;
}

/* Vignette */
.screen::before {
  content: '';
  position: absolute;
  inset: 0;
  background: radial-gradient(ellipse at 50% 50%, transparent 55%, rgba(0,0,0,0.55) 100%);
  pointer-events: none;
  z-index: 101;
}

/* Screen flicker */
.screen.on { animation: flicker 8s linear infinite; }

@keyframes flicker {
  0%    { opacity: 1; }
  3%    { opacity: 0.98; }
  6%    { opacity: 1; }
  42%   { opacity: 1; }
  44%   { opacity: 0.97; }
  46%   { opacity: 1; }
  87%   { opacity: 1; }
  88.5% { opacity: 0.96; }
  90%   { opacity: 1; }
  100%  { opacity: 1; }
}

/* Screen glare */
.screen-glare {
  position: absolute;
  inset: 0;
  background: linear-gradient(
    125deg,
    rgba(255,255,255,0.025) 0%,
    transparent 35%,
    transparent 65%,
    rgba(255,255,255,0.01) 100%
  );
  pointer-events: none;
  z-index: 103;
}

/* Noise */
.noise {
  position: absolute;
  inset: -50%;
  width: 200%; height: 200%;
  z-index: 102;
  pointer-events: none;
  opacity: 0.035;
  background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 256 256' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.85' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23n)'/%3E%3C/svg%3E");
  background-size: 128px;
  animation: noise-shift 0.4s steps(8) infinite;
}

@keyframes noise-shift {
  0%   { transform: translate(0, 0); }
  25%  { transform: translate(-4px, 3px); }
  50%  { transform: translate(3px, -4px); }
  75%  { transform: translate(-2px, -2px); }
  100% { transform: translate(4px, 2px); }
}

/* Interference line */
.interference {
  position: absolute;
  left: 0; right: 0;
  height: 3px;
  background: linear-gradient(90deg, transparent, rgba(51,255,0,0.06), transparent);
  z-index: 99;
  pointer-events: none;
  animation: interference-scroll 7s linear infinite;
}

@keyframes interference-scroll {
  0%   { top: 110%; }
  100% { top: -3px; }
}

/* ─── CRT TURN-ON EFFECT ─── */
.crt-turnon {
  position: absolute;
  inset: 0;
  background: var(--screen-off);
  z-index: 300;
  display: flex;
  align-items: center;
  justify-content: center;
}

.crt-turnon .h-line {
  width: 80%;
  height: 2px;
  background: var(--phosphor);
  box-shadow: 0 0 15px var(--phosphor-glow), 0 0 40px var(--phosphor-glow-soft);
  opacity: 0;
  transform: scaleX(0);
}

.crt-turnon.phase-1 .h-line {
  animation: hline-grow 0.5s ease-out forwards;
}

.crt-turnon.phase-2 {
  animation: screen-expand 0.35s ease-in forwards;
}
.crt-turnon.phase-2 .h-line {
  opacity: 1;
  transform: scaleX(1);
}

@keyframes hline-grow {
  0%   { opacity: 0; transform: scaleX(0); }
  30%  { opacity: 1; }
  100% { opacity: 1; transform: scaleX(1); }
}

@keyframes screen-expand {
  0%   { background: var(--screen-off); clip-path: inset(49% 0 49% 0); }
  60%  { background: rgba(51,255,0,0.08); clip-path: inset(0 0 0 0); }
  100% { background: transparent; clip-path: inset(0 0 0 0); opacity: 0; }
}

/* ─── BOOT SCREEN ─── */
.boot-screen {
  position: absolute;
  inset: 0;
  padding: 20px;
  padding-top: calc(20px + env(safe-area-inset-top));
  background: var(--screen-bg);
  display: none;
  flex-direction: column;
  z-index: 200;
  color: var(--phosphor);
  text-shadow: 0 0 8px var(--phosphor-glow);
  overflow: hidden;
}

.boot-screen.active { display: flex; }

.boot-text {
  font-size: 15px;
  line-height: 1.7;
  white-space: pre;
  flex-shrink: 0;
}

.boot-title-area {
  flex: 1;
  display: none;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  gap: 6px;
}

.boot-title-area.active { display: flex; }

.boot-title {
  font-size: clamp(32px, 8vw, 52px);
  letter-spacing: 4px;
  text-shadow: 0 0 20px var(--phosphor-glow), 0 0 50px var(--phosphor-glow-soft);
  text-align: center;
}

.boot-subtitle {
  font-size: 18px;
  letter-spacing: 3px;
  opacity: 0.5;
}

.boot-start {
  font-size: 20px;
  margin-top: 28px;
  animation: blink-cursor 1s step-end infinite;
  cursor: pointer;
}

@keyframes blink-cursor {
  0%, 100% { opacity: 1; }
  50%      { opacity: 0; }
}

/* ─── GAME UI ─── */
.game-screen {
  display: none;
  flex-direction: column;
  flex: 1;
  position: relative;
  z-index: 10;
}

.game-screen.active {
  display: flex;
}

/* Top Bar */
.top-bar {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 12px;
  flex-shrink: 0;
}

.pause-btn {
  background: none;
  border: 1px solid rgba(51,255,0,0.3);
  color: var(--phosphor);
  font-family: 'VT323', monospace;
  font-size: 16px;
  padding: 3px 10px;
  cursor: pointer;
  text-shadow: 0 0 6px var(--phosphor-glow);
  transition: all 0.2s;
  line-height: 1;
}

.pause-btn:hover {
  background: rgba(51,255,0,0.08);
  border-color: var(--phosphor);
  box-shadow: 0 0 8px var(--phosphor-glow-soft);
}

.top-info {
  display: flex;
  gap: 16px;
  font-size: clamp(18px, 4vw, 24px);
  color: var(--phosphor);
  text-shadow: 0 0 8px var(--phosphor-glow);
}

.top-info span {
  white-space: nowrap;
}

/* Grid */
.grid-area {
  flex: 1;
  display: flex;
  align-items: center;
  justify-content: center;
}

.grid {
  display: grid;
  grid-template-columns: repeat(5, 1fr);
  gap: 5px;
  width: min(100%, 380px);
  aspect-ratio: 1;
}

/* Cells */
.cell {
  aspect-ratio: 1;
  background: var(--phosphor-dim);
  border: 1px solid rgba(51, 255, 0, 0.06);
  border-radius: 2px;
  cursor: pointer;
  position: relative;
  transition: background 0.6s ease-out, box-shadow 0.6s ease-out, border-color 0.6s ease-out;
}

.cell::after {
  content: '';
  position: absolute;
  inset: 0;
  border-radius: 2px;
  opacity: 0;
  transition: opacity 0.6s ease-out;
  background: radial-gradient(circle at center, rgba(255,255,255,0.15), transparent 70%);
}

.cell:not(.lit):not(.selected):not(.correct):not(.wrong):not(.missed):hover {
  background: rgba(51, 255, 0, 0.12);
  border-color: rgba(51, 255, 0, 0.2);
}

/* Lit cells (during memorize) */
.cell.lit {
  background: var(--phosphor);
  border-color: rgba(51, 255, 0, 0.4);
  box-shadow: 0 0 12px var(--phosphor-glow), 0 0 25px var(--phosphor-glow-soft);
  transition: background 0.06s ease-in, box-shadow 0.06s ease-in, border-color 0.06s ease-in;
}
.cell.lit::after {
  opacity: 1;
  transition: opacity 0.06s ease-in;
}

/* Selected cells (during input) */
.cell.selected {
  background: var(--phosphor);
  border-color: rgba(51, 255, 0, 0.4);
  box-shadow: 0 0 12px var(--phosphor-glow), 0 0 20px var(--phosphor-glow-soft);
  transition: background 0.06s, box-shadow 0.06s;
}
.cell.selected::after { opacity: 1; transition: opacity 0.06s; }

/* Correct */
.cell.correct {
  background: var(--phosphor-bright);
  border-color: rgba(127, 255, 51, 0.5);
  box-shadow: 0 0 18px var(--phosphor-glow), 0 0 35px var(--phosphor-glow-soft);
  transition: all 0.15s;
  animation: cell-correct-pop 0.35s ease;
}
.cell.correct::after { opacity: 1; }

@keyframes cell-correct-pop {
  0%   { transform: scale(1); }
  40%  { transform: scale(1.08); }
  100% { transform: scale(1); }
}

/* Wrong */
.cell.wrong {
  background: #3d0000;
  border-color: #880000;
  box-shadow: 0 0 12px rgba(255, 0, 0, 0.25);
  transition: all 0.15s;
}
.cell.wrong::after { opacity: 0; }

/* Missed */
.cell.missed {
  background: var(--phosphor-mid);
  border-color: rgba(51, 255, 0, 0.2);
  box-shadow: 0 0 8px var(--phosphor-glow-soft);
  animation: cell-missed-blink 0.35s ease 3;
  transition: all 0.15s;
}

@keyframes cell-missed-blink {
  0%, 100% { opacity: 1; }
  50%      { opacity: 0.3; }
}

/* Status */
.status-area {
  flex-shrink: 0;
  text-align: center;
  padding-top: 14px;
}

.status-text {
  font-size: clamp(22px, 5vw, 30px);
  color: var(--phosphor);
  text-shadow: 0 0 12px var(--phosphor-glow);
  min-height: 1.3em;
  letter-spacing: 2px;
}

.status-text.blink { animation: blink-cursor 1s step-end infinite; }

.status-sub {
  font-size: 16px;
  color: var(--phosphor);
  text-shadow: 0 0 6px var(--phosphor-glow);
  min-height: 1.3em;
  opacity: 0.5;
  margin-top: 2px;
}

/* ─── PAUSE OVERLAY ─── */
.pause-overlay {
  position: absolute;
  inset: 0;
  background: rgba(0, 10, 0, 0.92);
  display: none;
  align-items: center;
  justify-content: center;
  z-index: 150;
  font-size: clamp(36px, 10vw, 56px);
  color: var(--phosphor);
  text-shadow: 0 0 25px var(--phosphor-glow), 0 0 50px var(--phosphor-glow-soft);
  letter-spacing: 10px;
}
.pause-overlay.active {
  display: flex;
  animation: blink-cursor 1.2s step-end infinite;
}

/* ─── GAME OVER ─── */
.gameover-screen {
  position: absolute;
  inset: 0;
  padding: 20px;
  background: var(--screen-bg);
  display: none;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  z-index: 200;
  color: var(--phosphor);
  text-shadow: 0 0 12px var(--phosphor-glow);
  gap: 8px;
}
.gameover-screen.active { display: flex; }

.gameover-label {
  font-size: 20px;
  letter-spacing: 3px;
  opacity: 0.6;
}

.gameover-msg {
  font-size: clamp(28px, 7vw, 42px);
  letter-spacing: 3px;
  text-shadow: 0 0 20px var(--phosphor-glow);
}

.gameover-score {
  font-size: clamp(48px, 12vw, 72px);
  text-shadow: 0 0 30px var(--phosphor-glow), 0 0 60px var(--phosphor-glow-soft);
  line-height: 1;
  margin: 8px 0;
}

.gameover-detail {
  font-size: 16px;
  opacity: 0.4;
  margin-bottom: 10px;
}

.gameover-restart {
  font-size: 20px;
  margin-top: 20px;
  animation: blink-cursor 1s step-end infinite;
  cursor: pointer;
}

/* Score popup */
.score-pop {
  position: absolute;
  font-size: 22px;
  color: var(--phosphor-bright);
  text-shadow: 0 0 10px var(--phosphor-glow);
  animation: pop-float 0.9s ease-out forwards;
  pointer-events: none;
  z-index: 50;
  white-space: nowrap;
}

@keyframes pop-float {
  0%   { transform: translateY(0); opacity: 1; }
  100% { transform: translateY(-35px); opacity: 0; }
}

/* ─── RESPONSIVE ─── */
@media (max-height: 650px) {
  .screen { padding: 10px 14px; }
  .grid { width: min(100%, 300px); }
  .top-bar { margin-bottom: 6px; }
  .status-area { padding-top: 8px; }
}

@media (max-width: 380px) {
  .grid { gap: 4px; }
}
</style>
</head>
<body>

<div class="monitor">
  <div class="screen-wrapper">
    <div class="screen" id="screen">

      <!-- CRT Turn-on -->
      <div class="crt-turnon" id="crtTurnon">
        <div class="h-line"></div>
      </div>

      <!-- Boot Screen -->
      <div class="boot-screen" id="bootScreen">
        <div class="boot-text" id="bootText"></div>
        <div class="boot-title-area" id="bootTitleArea">
          <div class="boot-title">DO NOT FORGET</div>
          <div class="boot-subtitle">CRT EDITION v1.0</div>
          <div class="boot-start" id="bootStart">[ PRESS ANY KEY ]</div>
        </div>
      </div>

      <!-- Game Screen -->
      <div class="game-screen" id="gameScreen">
        <div class="top-bar">
          <button class="pause-btn" id="pauseBtn">| |</button>
          <div class="top-info">
            <span id="trialDisplay">TRIAL 1/12</span>
            <span id="scoreDisplay">SCORE 0</span>
          </div>
        </div>
        <div class="grid-area">
          <div class="grid" id="grid"></div>
        </div>
        <div class="status-area">
          <div class="status-text" id="statusText"></div>
          <div class="status-sub" id="statusSub"></div>
        </div>
      </div>

      <!-- Pause Overlay -->
      <div class="pause-overlay" id="pauseOverlay">PAUSED</div>

      <!-- Game Over Screen -->
      <div class="gameover-screen" id="gameoverScreen">
        <div class="gameover-label">GAME COMPLETE</div>
        <div class="gameover-msg" id="gameoverMsg">WELL DONE</div>
        <div class="gameover-label">FINAL SCORE</div>
        <div class="gameover-score" id="gameoverScore">0</div>
        <div class="gameover-detail" id="gameoverDetail"></div>
        <div class="gameover-restart" id="gameoverRestart">[ PRESS ANY KEY ]</div>
      </div>

      <!-- Effect Layers -->
      <div class="noise"></div>
      <div class="interference"></div>
      <div class="screen-glare"></div>

    </div>
  </div>
</div>

<script>
// ─────────────────────────────────────────
// AUDIO ENGINE (Web Audio API)
// ─────────────────────────────────────────
let audioCtx = null;

function ensureAudio() {
  if (!audioCtx) {
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  }
  if (audioCtx.state === 'suspended') audioCtx.resume();
}

function tone(freq, dur, type = 'square', vol = 0.07) {
  if (!audioCtx) return;
  const t = audioCtx.currentTime;
  const osc = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  osc.type = type;
  osc.frequency.setValueAtTime(freq, t);
  g.gain.setValueAtTime(vol, t);
  g.gain.exponentialRampToValueAtTime(0.0001, t + dur);
  osc.connect(g);
  g.connect(audioCtx.destination);
  osc.start(t);
  osc.stop(t + dur);
}

const sfx = {
  pip:     () => tone(920, 0.045, 'square', 0.06),
  click:   () => tone(500, 0.025, 'square', 0.05),
  declick: () => tone(350, 0.025, 'square', 0.04),
  success: () => {
    tone(523, 0.1, 'square', 0.055);
    setTimeout(() => tone(659, 0.1, 'square', 0.055), 90);
    setTimeout(() => tone(784, 0.14, 'square', 0.055), 180);
  },
  perfect: () => {
    [523, 659, 784, 1047].forEach((f, i) =>
      setTimeout(() => tone(f, 0.12, 'square', 0.055), i * 70)
    );
  },
  error:   () => tone(140, 0.3, 'sawtooth', 0.07),
  boot:    () => tone(1000, 0.06, 'sine', 0.03),
  bootOk:  () => { tone(800, 0.05, 'sine', 0.03); setTimeout(() => tone(1200, 0.08, 'sine', 0.03), 60); },
};

// ─────────────────────────────────────────
// GAME STATE
// ─────────────────────────────────────────
const state = {
  trial: 1,
  maxTrials: 12,
  score: 0,
  phase: 'off',       // off, boot, title, memorize, input, feedback, gameover
  pattern: [],
  selected: [],
  gridSize: 5,
  paused: false,
  canClick: false,
  perfectCount: 0,
  timers: [],
};

function patternSize(trial) {
  return 3 + Math.floor((trial - 1) / 2);
}

function memorizeTime(trial) {
  return Math.max(1100, 2600 - (trial - 1) * 130);
}

// ─────────────────────────────────────────
// DOM REFERENCES
// ─────────────────────────────────────────
const $ = id => document.getElementById(id);

const els = {
  screen:         $('screen'),
  crtTurnon:      $('crtTurnon'),
  bootScreen:     $('bootScreen'),
  bootText:       $('bootText'),
  bootTitleArea:  $('bootTitleArea'),
  bootStart:      $('bootStart'),
  gameScreen:     $('gameScreen'),
  grid:           $('grid'),
  trialDisplay:   $('trialDisplay'),
  scoreDisplay:   $('scoreDisplay'),
  statusText:     $('statusText'),
  statusSub:      $('statusSub'),
  pauseBtn:       $('pauseBtn'),
  pauseOverlay:   $('pauseOverlay'),
  gameoverScreen: $('gameoverScreen'),
  gameoverMsg:    $('gameoverMsg'),
  gameoverScore:  $('gameoverScore'),
  gameoverDetail: $('gameoverDetail'),
  gameoverRestart:$('gameoverRestart'),
};

// ─────────────────────────────────────────
// UTILITIES
// ─────────────────────────────────────────
const sleep = ms => new Promise(r => {
  const id = setTimeout(r, ms);
  state.timers.push(id);
});

function clearTimers() {
  state.timers.forEach(clearTimeout);
  state.timers = [];
}

function getCells() {
  return Array.from(els.grid.querySelectorAll('.cell'));
}

// ─────────────────────────────────────────
// GRID
// ─────────────────────────────────────────
function buildGrid() {
  els.grid.innerHTML = '';
  const total = state.gridSize * state.gridSize;
  for (let i = 0; i < total; i++) {
    const cell = document.createElement('div');
    cell.className = 'cell';
    cell.dataset.idx = i;
    cell.addEventListener('click', () => onCellClick(i));
    els.grid.appendChild(cell);
  }
}

// ─────────────────────────────────────────
// PATTERN GENERATION
// ─────────────────────────────────────────
function generatePattern(count) {
  const total = state.gridSize * state.gridSize;
  const set = new Set();
  while (set.size < count) {
    set.add(Math.floor(Math.random() * total));
  }
  return [...set];
}

// ─────────────────────────────────────────
// GAME FLOW
// ─────────────────────────────────────────
function showPattern() {
  const cells = getCells();
  state.pattern.forEach((idx, i) => {
    const id = setTimeout(() => {
      cells[idx].classList.add('lit');
      sfx.pip();
    }, i * 70);
    state.timers.push(id);
  });
}

function hidePattern() {
  getCells().forEach(c => c.classList.remove('lit'));
}

function resetCells() {
  getCells().forEach(c => {
    c.className = 'cell';
  });
}

async function startTrial() {
  state.phase = 'memorize';
  state.selected = [];
  state.canClick = false;

  resetCells();

  els.trialDisplay.textContent = `TRIAL ${state.trial}/${state.maxTrials}`;
  els.statusSub.textContent = '';

  const pSize = patternSize(state.trial);
  state.pattern = generatePattern(pSize);

  // Brief pause, then show
  els.statusText.textContent = 'MEMORIZE';
  els.statusText.classList.remove('blink');

  await sleep(600);
  if (state.phase !== 'memorize') return;

  showPattern();

  const revealDur = state.pattern.length * 70;
  const memTime = memorizeTime(state.trial);

  await sleep(revealDur + memTime);
  if (state.phase !== 'memorize') return;

  hidePattern();

  await sleep(200);
  if (state.phase !== 'memorize') return;

  // Switch to input
  state.phase = 'input';
  state.canClick = true;
  els.statusText.textContent = 'YOUR TURN';
  els.statusText.classList.add('blink');
  els.statusSub.textContent = `0 / ${pSize}`;
}

function onCellClick(index) {
  if (state.phase !== 'input' || state.paused || !state.canClick) return;

  const cells = getCells();
  const cell = cells[index];

  if (state.selected.includes(index)) {
    state.selected = state.selected.filter(i => i !== index);
    cell.classList.remove('selected');
    sfx.declick();
  } else {
    state.selected.push(index);
    cell.classList.add('selected');
    sfx.click();
  }

  const pSize = patternSize(state.trial);
  els.statusSub.textContent = `${state.selected.length} / ${pSize}`;

  if (state.selected.length >= pSize) {
    state.canClick = false;
    setTimeout(() => evaluate(), 250);
  }
}

async function evaluate() {
  state.phase = 'feedback';
  els.statusText.classList.remove('blink');

  const cells = getCells();
  const pSize = patternSize(state.trial);

  let correct = 0;
  let wrong = 0;

  // Mark selected as correct or wrong
  state.selected.forEach(idx => {
    if (state.pattern.includes(idx)) {
      cells[idx].classList.remove('selected');
      cells[idx].classList.add('correct');
      correct++;
    } else {
      cells[idx].classList.remove('selected');
      cells[idx].classList.add('wrong');
      wrong++;
    }
  });

  // Mark missed
  state.pattern.forEach(idx => {
    if (!state.selected.includes(idx)) {
      cells[idx].classList.add('missed');
    }
  });

  const perfect = correct === pSize && wrong === 0;
  const points = Math.max(0, correct * 10 - wrong * 5) + (perfect ? 50 : 0);

  if (perfect) state.perfectCount++;

  state.score += points;
  els.scoreDisplay.textContent = `SCORE ${state.score}`;

  // Status
  if (perfect) {
    els.statusText.textContent = '>>> PERFECT <<<';
    sfx.perfect();
  } else if (correct > wrong) {
    els.statusText.textContent = `${correct}/${pSize} CORRECT`;
    sfx.success();
  } else {
    els.statusText.textContent = 'MISS';
    sfx.error();
  }

  if (points > 0) {
    els.statusSub.textContent = `+${points} PTS`;
    showScorePop(points);
  } else {
    els.statusSub.textContent = '';
  }

  await sleep(2000);
  if (state.phase !== 'feedback') return;

  if (state.trial >= state.maxTrials) {
    showGameOver();
  } else {
    state.trial++;
    startTrial();
  }
}

function showScorePop(pts) {
  const pop = document.createElement('div');
  pop.className = 'score-pop';
  pop.textContent = `+${pts}`;
  // Position near the score display
  const rect = els.scoreDisplay.getBoundingClientRect();
  const screenRect = els.screen.getBoundingClientRect();
  pop.style.right = '18px';
  pop.style.top = `${rect.bottom - screenRect.top + 4}px`;
  els.screen.appendChild(pop);
  setTimeout(() => pop.remove(), 950);
}

// ─────────────────────────────────────────
// GAME OVER
// ─────────────────────────────────────────
function showGameOver() {
  state.phase = 'gameover';
  els.gameoverScreen.classList.add('active');
  els.gameoverScore.textContent = state.score;

  // Determine message
  const pct = state.perfectCount / state.maxTrials;
  if (pct >= 0.9)      els.gameoverMsg.textContent = 'FLAWLESS';
  else if (pct >= 0.6) els.gameoverMsg.textContent = 'EXCELLENT';
  else if (pct >= 0.3) els.gameoverMsg.textContent = 'WELL DONE';
  else                 els.gameoverMsg.textContent = 'GAME OVER';

  els.gameoverDetail.textContent = `${state.perfectCount}/${state.maxTrials} PERFECT TRIALS`;

  // Restart listener
  const handler = () => {
    document.removeEventListener('keydown', handler);
    els.gameoverRestart.removeEventListener('click', handler);
    restartGame();
  };
  setTimeout(() => {
    document.addEventListener('keydown', handler);
    els.gameoverRestart.addEventListener('click', handler);
  }, 600);
}

function restartGame() {
  ensureAudio();
  sfx.pip();
  els.gameoverScreen.classList.remove('active');
  state.trial = 1;
  state.score = 0;
  state.perfectCount = 0;
  state.selected = [];
  state.pattern = [];
  els.scoreDisplay.textContent = 'SCORE 0';
  startTrial();
}

// ─────────────────────────────────────────
// PAUSE
// ─────────────────────────────────────────
function togglePause() {
  if (state.phase === 'off' || state.phase === 'boot' || state.phase === 'title' || state.phase === 'gameover') return;
  state.paused = !state.paused;
  els.pauseOverlay.classList.toggle('active', state.paused);
  els.pauseBtn.textContent = state.paused ? ' > ' : '| |';
}

els.pauseBtn.addEventListener('click', togglePause);
document.addEventListener('keydown', e => {
  if (e.key === 'Escape' || e.key === 'p' || e.key === 'P') {
    if (state.phase !== 'off' && state.phase !== 'boot' && state.phase !== 'title') {
      togglePause();
    }
  }
});

// ─────────────────────────────────────────
// BOOT SEQUENCE
// ─────────────────────────────────────────
async function bootSequence() {
  state.phase = 'boot';

  // Phase 1: CRT turn-on line
  await sleep(400);
  els.crtTurnon.classList.add('phase-1');
  await sleep(600);

  // Phase 2: expand to full screen
  els.crtTurnon.classList.add('phase-2');
  els.screen.classList.add('on');
  await sleep(450);

  els.crtTurnon.style.display = 'none';
  els.bootScreen.classList.add('active');

  // Boot text lines
  const lines = [
    'DO NOT FORGET BIOS v2.04',
    'COPYRIGHT (C) 2026 THIS WHOLE WORLD LLC.',
    '',
    'CHECKING SYSTEM ...',
    '  PHOSPHOR ARRAY ........ OK',
    '  VIDEO RAM 64K ......... OK',
    '  PATTERN GENERATOR ..... OK',
    '  SCORE REGISTER ........ OK',
    '',
    'ALL SYSTEMS NOMINAL.',
    'LOADING DO NOT FORGET ...',
  ];

  for (const line of lines) {
    els.bootText.textContent += line + '\n';
    sfx.boot();
    await sleep(120 + Math.random() * 100);
  }

  // Progress bar
  const bar = '||||||||||||||||||||';
  for (let i = 1; i <= bar.length; i++) {
    els.bootText.textContent =
      els.bootText.textContent.replace(/LOADING DO NOT FORGET \.\.\.[\s\S]*$/, '') +
      'LOADING DO NOT FORGET ...\n  [' + bar.slice(0, i) + ' '.repeat(bar.length - i) + '] ' + Math.round((i / bar.length) * 100) + '%';
    await sleep(40);
  }

  sfx.bootOk();
  await sleep(400);

  // Show title
  els.bootText.style.display = 'none';
  els.bootTitleArea.classList.add('active');

  state.phase = 'title';

  // Wait for any key / click
  return new Promise(resolve => {
    const handler = () => {
      document.removeEventListener('keydown', handler);
      document.removeEventListener('click', clickHandler);
      resolve();
    };
    const clickHandler = (e) => {
      // Ignore clicks on boot start only after a moment
      document.removeEventListener('keydown', handler);
      document.removeEventListener('click', clickHandler);
      resolve();
    };
    document.addEventListener('keydown', handler);
    document.addEventListener('click', clickHandler);
  });
}

// ─────────────────────────────────────────
// INIT
// ─────────────────────────────────────────
async function init() {
  buildGrid();

  await bootSequence();

  ensureAudio();
  sfx.pip();

  // Transition to game
  els.bootScreen.classList.remove('active');
  els.gameScreen.classList.add('active');

  startTrial();
}

init();
</script>
<script>
// Hide status bar on iOS for full immersion
if (window.Capacitor) {
  import('@capacitor/status-bar').then(({ StatusBar }) => {
    StatusBar.hide();
  }).catch(() => {});
}
</script>
</body>
</html>
